# 1. 图论相关算法

[强烈推荐：【宫水三叶】涵盖所有「存图方式」与「最短路算法」(史上最全)](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solutions/2526052/gong-shui-san-xie-han-gai-suo-you-cun-tu-svq7/)

# 2. floyed 算法

中 起 终，有手就行。。。

```java
void floyd(int[][] g) {
    int n = g.length;
    // floyd 基本流程为三层循环: [枚举中转点 - 枚举起点 - 枚举终点] => 松弛操作
    for (int p = 0; p < n; p++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                g[i][j] = Math.min(g[i][j], g[i][p] + g[p][j]);
            }
        }
    }
}
```

# 3. Dijkstra

和bfs很像啊，区别在于

1. 使用了一个数组去记录遍历情况（很重要，主要是防止重复访问点，a也能到b，c也能到b，且先从a到b，后来发现c到b更短，添加了c到b的路径，会导致重复遍历）
2. 每次选的都是距离最短的点

```java
    int[] dijkstra(int x) {
        // 起始先将所有的点标记为「未更新」和「距离为正无穷」
        int[] dist = new int[n];
        Arrays.fill(dist, 0x3f3f3f3f);
        boolean[] vis = new boolean[n];
        dist[x] = 0;
        // 使用「优先队列」存储所有可用于更新的点
        // 以 (点编号, 到起点的距离) 进行存储，优先弹出「最短距离」较小的点
        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->a[1]-b[1]);
        q.add(new int[]{x, 0});
        while (!q.isEmpty()) {
            // 每次从「优先队列」中弹出
            int[] poll = q.poll();
            int u = poll[0], step = poll[1];
            // 如果弹出的点被标记「已更新」，则跳过
            if (vis[u]) continue;
            // 标记该点「已更新」，并使用该点更新其他点的「最短距离」
            vis[u] = true;
            for (int i = he[u]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] <= dist[u] + w[i]) continue;
                dist[j] = dist[u] + w[i];
                q.add(new int[]{j, dist[j]});
            }
        }
        return dist;
    }
```