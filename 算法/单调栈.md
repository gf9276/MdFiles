# 1. 题目

```
3113. 边界元素是最大值的子数组数目
2866. 美丽塔 II
456. 132 模式
2454. 下一个更大元素 IV （单调栈和优先队列的结合）
907. 子数组的最小值之和
```

# 2. 132 模式

以这个为样例，其实单调栈很简单，保持栈内元素有序即可

```java
class Solution {
    public boolean find132pattern(int[] nums) {
        // 这题目有点神奇，其实转念一想
        // 2 的 左边有两个数，比他大的和比他小的，比他大的在比他小的的右边
        // 所以 双单调栈

        int[] leftBigger = new int[nums.length];
        Arrays.fill(leftBigger, -1); // 左边没有比他大的

        Deque<Integer> queue1 = new LinkedList<>(); // 单调栈正三角
        int k = Integer.MIN_VALUE;

        // 先算左侧
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] < k) {
                return true;
            }
            while (!queue1.isEmpty() && nums[queue1.peekFirst()] < nums[i]) {
                k = Math.max(k, nums[queue1.pollFirst()]);
            }
            queue1.addFirst(i);
        }

        return false;
    }
}
```

# 3. 子数组的最小值之和

很明显的单调栈题目，注意最后计算的时候 i 索引转 long 就不会爆范围

```java
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int mod = 1000000007;

        // 是这样的，选定 i 看看 i 的影响力
        // 左 m 右 n，一共就有(m+1)*(n+1)种可能

        int[] leftSmaller = new int[arr.length];
        int[] rightSmaller = new int[arr.length];
        Arrays.fill(leftSmaller, -1);
        Arrays.fill(rightSmaller, arr.length); // 默认就是没有啦

        Deque<Integer> stack = new LinkedList<>();

        // 先计算右边的
        for (int i = 0; i < arr.length; i++) {
            while (!stack.isEmpty() && arr[stack.peekFirst()] >= arr[i]) {
                // 那就弹出来
                rightSmaller[stack.pollFirst()] = i;
            }
            stack.addFirst(i);
        }

        stack.clear();

        for (int i = arr.length - 1; i >= 0; i--) {
            while (!stack.isEmpty() && arr[stack.peekFirst()] > arr[i]) {
                // 为了防止重复，这里没有等于号
                leftSmaller[stack.pollFirst()] = i;
            }
            stack.addFirst(i);
        }

        // 算完了，计算答案
        long output = 0;

        for (int i = 0; i < arr.length; i++) {
            output = (output + (long) (i - leftSmaller[i]) * (rightSmaller[i] - i) * arr[i]) % mod;
        }
        return (int) output;
    }
}
```
