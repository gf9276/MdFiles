# 1. mysql

## explain

https://blog.csdn.net/qq_37149892/article/details/108531135

### id

### table

查的哪张表

### select_type

普通 复杂 子查询

### possible_key

可能用到的索引

### key

实际用到的索引

### key_len

索引字段的长度

### type

all 全表

index 走索引的全表

range 范围，基于索引

ref 一个值的多条记录

eq_red 一个值的一条记录

const 秒杀，直接查出一条记录？？？

## 1.1. 基本概念

什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？

元组 --> 行

码 --> 唯一标识

候选码 --> 码的子集

主码 --> 候选码里挑出来的

外码 --> 外键

主属性 --> 候选码里出现过的

非主属性 --> 除了主属性外的呗

---

主码    候选码   码

ps：元组理解为一张表的某一行，属性理解为一张表的某一列，属性名就是列的名字（字段）。

1（码）：码是可以确定一个元组的所有信息的属性名或属性名组。

例如在 { a, b, c, d } 中，

假设知道 a 的值就能确定  a, b, c, d  的值，

假设知道 c, d 的值就可以确定  a, b, c, d  的值，

那么 { a } 就是码，{ c, d } 就是码。

并且 { a, b }, { a, c }, { a, b, c }, { a, b, c, d } 等也都是码，因为它们也可以确定一个元组的所有值，即使很多余。

2（候选码）：候选码的真子集中不存在码，候选码可以有多个。

就上面的例子而言，{ a } 是候选码，{ c, d } 是候选码，因为它们的真子集中不存在码。

而诸如 { a, b } 并不是候选码，因为它的真子集中含有 { a }， 且 { a } 是码。

3（主码）：主码就是主键的意思，主码是任意一个候选码。

还是上面的例子，主码是候选码 { a }， { c, d } 中的其中一个。

既可以是 { a }， 也可以是 { c, d }。 

## 1.2. 数据库范式

[参考链接](https://blog.csdn.net/A_art_xiang/article/details/113880638#:~:text=%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%94%E8%AF%A5%E5%85%B7%E6%9C%89%E2%80%9C%E4%B8%8D%E5%8F%AF%E5%86%8D%E5%88%86%E6%80%A7%E2%80%9D%EF%BC%89%20%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89%EF%BC%9A%E5%94%AF%E4%B8%80%E6%80%A7,%28%E6%B6%88%E9%99%A4%E9%9D%9E%E4%B8%BB%E9%94%AE%E9%83%A8%E5%88%86%E4%BE%9D%E8%B5%96%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%29%EF%BC%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%E5%B7%B2%E7%BB%8F%E6%BB%A1%E8%B6%B3%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%89%20%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89%EF%BC%9A%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%8C%E6%B6%88%E9%99%A4%E4%BC%A0%E9%80%92%E4%BE%9D%E8%B5%96%20%28%E9%9D%9E%E4%B8%BB%E9%94%AE%E5%80%BC%E4%B8%8D%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9D%9E%E4%B8%BB%E9%94%AE%E5%80%BC%29)


第一范式：不可再分

第二范式：局部依赖

第三范式：链式依赖

## 1.3. 分库分表

## 1.4. 提高效率

不要用字符串存储时间，用timestamp，带时区

用定点数

使用自增id作为主键

不要用null作为列默认值



## 1.5. select * 

select * 效率低下，无法使用覆盖索引


## 1.6. update where 条件没加索引


## 1.7. count(*)

## 1.8. b树和b+树

[写的不错的解析](https://blog.csdn.net/a519640026/article/details/106940115)

B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树（B树是一颗多路平衡查找树）
它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。

b树就是把数据分成一个个区块，然后和平衡树不同的是，他存的是一个区块，而不是一个数据点，这么干主要是为了利于从磁盘中读取。

空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。

**有个问题哈，我为什么不直接在双向链表上做查找和插入呢？效率也是O(logn)**


b+树，相较于b树，非叶子节点只存储key，叶子节点会连着存储data，好处是数据在磁盘上更加连续了，更适合mysql了

* B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
* B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
* B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

B+树的每个节点都是一个16KB的数据页

## mvcc 多版本并发控制

乐观锁，快照机制

当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改

当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。

和git或者说是在线文档一个思路

