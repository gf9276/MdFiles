[简单的demo](https://github.com/youlookwhat/DesignPattern?tab=readme-ov-file#5-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F)
[简单的demo2](https://cloud.tencent.com/developer/article/1602270)
https://www.mianshiya.com/bank/1801559627969929217/question/1804016809748930562

设计模式是一套在软件工程中经过验证的、用于解决特定设计问题的解决方案模板，它们帮助开发者避免重复发明轮子，确保设计的一致性和可维护性，提高代码的可读性和可扩展性


# 1. 项目里用到了哪些设计模式

只能编出三个啊（加个策略吧，嘻嘻）

## 1.1. 模板模式

这个肯定对的。

模板模式是针对一个类做的，策略模式是选择不同的策略

模板方法：java里的，训练任务整体的处理流程是一模一样的，不管你是分类任务、还是分割任务。可能就是针对不同的任务类型（分类、分割，是初步训练啊还是做微调）有部分区别。无非就是工作空间创建的不一样，模型的来源不一样，模型不一样。这里呢，使用模板方法固定顺序，然后钩子方法自定义部分操作，有就加上，没有就不加。


模板方法：没有用在java里，写python训练代码的时候用的。我开始做项目的时候，任务要分派给不同的同学吗，然后我就发现，每个人由于水平的问题，毕竟我们不是科班，他写代码的质量就参差不齐，风格也不统一。像我们做深度学习训练或者预测的时候，整体的流程是固定的，创建模型、加载数据、加载到GPU里，创建优化器、创建学习率优化器，然后开始训练/预测，然后做训练，训练过程中还要进程日志记录，根据指标判断模型权重的保存。不同任务类别，细节处可能不一样，但是大致的流程是差不多。现有的lighting其实和测井任务不太匹配。我就针对测井任务写了一个深度学习通用模板给我们实验室用，他们训练的时候自己调用钩子函数调用监测器，比如aim或者tensorboard或者wandb都可以，或者仅重写stepRunner或者epochRunner就可以实现自定义训练+观测。

## 1.2. 单例模式

这个也是对的

单例模式：GPU资源管理（因为GPU资源在服务器上数量肯定是固定的嘛，所以创建了一个单例的类去管理他），连接池、单例的spring bean（默认的）。

## 1.3. 适配器模式

这个也是对的

适配器模式：数据集的格式很多，gdsx、h5、csv、甚至他们还把数据附着在请求体里，因为一开始定下的是h5格式的，所以一开始也只写了h5格式的接口。后面为了解决数据集格式不同的问题，中间加了一个转换层，对不同格式的数据集统一转换成h5格式，这样就能兼容以前写的接口了。

# 2. 装饰者模式

装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。

装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。

1. BufferInputStream 装饰 FileInputStream，实现缓冲数据流的功能。

# 3. 适配器模式

适配器（Adapter Pattern）模式 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。

数据集问题，算不算适配器模式？

适配器模式主要是为了兼容接口，太对了

1. 比如字节流到字符流的转换。
2. slf4j 使用适配器模式来统一不同的日志接口


# 4. 工厂模式

简单工厂 --> 工厂方法 --> 抽象工厂（可以有多个工厂）


不需要客户端自己去管建造的细节，直接返回创建好的对象。也不分什么构造器和指挥者。

它的主要目的是封装对象的创建过程，将创建对象的过程与使用对象的过程分离，从而使得系统更容易维护和扩展。

https://blog.csdn.net/qq_42804736/article/details/115168313

那么什么是简单工厂呢？简单工厂就是通过工厂类，将多个对象的创建和使用进行分离。不符合开闭原则，出现新的需求，需要对工厂类进行修改。

工厂方法？工厂方法就是使用一个工厂接口，创建多个工厂类，不同的工厂类创建各自的产品。

抽象工厂就是将上面两个结合起来，一个工厂可以创建多个对象，且不同的工厂实现了同一个工厂接口。

工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 Files 类的 newInputStream 方法用于创建 InputStream 对象（静态工厂）、 Paths 类的 get 方法创建 Path 对象（静态工厂）、ZipFileSystem 类（sun.nio包下的类，属于 java.nio 相关的一些内部实现）的 getPath 的方法创建 Path 对象（简单工厂）。

1. Files 类的 newInputStream 方法（静态工厂）
2. Spring 使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象

# 5. 观察者模式

发布订阅模式

观察者模式（Observer Pattern）是一种常用的行为设计模式，它定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动。

定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。

1. NIO肯定也是用了观察者的
2. 消息队列
3. Spring的事件

# 6. 单例模式

在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。

池化资源、日志、配置

双重锁

```java
public class Singleton{
    public Singleton(){}
    public static volatile instance = null;

    public static void getInstance()
    {
        if (instance == null){
            synchronized (Singleton.class)
            {
                if (instance == null)
                {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

1. Spring 中 bean 的默认作用域就是 singleton(单例)的。pring 通过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式

# 7. 代理模式

1. spring的aop就是基于代理实现的，权限控制，事务管理，日志 jdk proxy cglib proxy

和装饰器的区别主要在于，装饰器是为了增强原有功能。代理是为了增加额外的功能。


# 8. 建造者设计模式

写网关的时候，不是有个urlbuilder嘛？

构造器+指挥

创建比较复杂的类的时候，使用该模式，将一个复杂对象的创建和构建分离。

各种builder ProcessBuilder UrlBulder

# 9. 策略模式

策略模式有三个组成角色：
抽象策略(Strategy)类
具体策略(Concrete Strategy)类
环境(Context)类

根据用户的输入选择不同的策略

[郭霖](https://blog.csdn.net/u011240877/article/details/52346671)

[鸿洋](https://blog.csdn.net/lmj623565791/article/details/24116745)

[策略模式](https://blog.csdn.net/bookssea/article/details/117043820)

# 10. 命令模式

定义：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。(简化: 将请求封装成对象，将动作请求者和动作执行者解耦。)


# 11. 外观模式

说的好听，不就是把所有动作都和在一起。。。

定义：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。其实就是为了方便客户的使用，把一群操作，封装成一个方法。

以前做机器人

# 12. 模板方法

[模板方法](https://blog.csdn.net/zxd1435513775/article/details/120080387)

模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

简单来说，在父类中定义算法的大致流程框架，在子类中实现具体的步骤。

# 原型模式

通过一个对象迅速的创建出多个对象

clone

# 桥接模式

分离系统的多个维度或角度，使得系统的多个部分可以独立变化，比如加载数据库驱动

# 组合模式

将对象组合成树形结构，例如文件/部门员工管理

# 迭代器模式

提供一种方法顺序访问一个集合中的对象，而不暴露该对象的内部实现

# 状态模式

对象在内部状态改变时，改变其行为

不同状态的角色有不同的行为和动画。

或者说按键的状态决定了具体的反馈。

# 责任链

将多个对象串成一条链，沿着这条链子传递请求，让多个对象都有机会处理这个请求。比如servlet的过滤器

# 中介者

通过一个中介来协调各个节点的交互

# 访问者

通过不同的访问者，添加不同的操作

# 备忘录

也叫快照模式

将对象的状态封装在一个备忘录里，通过管理者进行保存和恢复。